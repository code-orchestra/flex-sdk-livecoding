#*
  Licensed to the Apache Software Foundation (ASF) under one or more
  contributor license agreements.  See the NOTICE file distributed with
  this work for additional information regarding copyright ownership.
  The ASF licenses this file to You under the Apache License, Version 2.0
  (the "License"); you may not use this file except in compliance with
  the License.  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
*#
#*
    ClassDef.vm

    Template for an AS3 class definition given (MxmlDocument $doc, VelocityUtil $util)

    Library macros defined in ClassDefLib.vm
*#/**
*  Generated by mxmlc 4.0
*
*  Package:    $doc.packageName
*  Class:      $doc.className
*  Source:     $doc.sourcePath
*  Template:   ${util.templatePath}ClassDef.vm
*  Time:       $util.timeStamp
*/

##
## begin package def
##
package $doc.packageName
{

##
## imports
##
#foreach ($nameInfo in $doc.imports)
## NOTE: the SWC contains actual, debuggable bytecode for import statements. To avoid unwanted
## BPs in the debugger, we use an explicitly compile-error-only mapping here.
    #embedTextMapCompileErrorsOnly("import $nameInfo.name;" $nameInfo.line)
#end

##
## ResourceBundle metadata autogenerated from @Resource directives
##
#foreach ($atResource in $doc.atResources)
[ResourceBundle("$atResource.bundle")]
#end

##
## metadata - may be internal or from <Metdata>; latter will be line-number mapped by embedText
##
#foreach ($md in $doc.metadata)
    #embedText($md.Text $md.xmlLineNumber)
#end

##
## begin class def
##
#trace("//  begin class def")
## attach a comment at the class level, if we care about comments. 
#if ($processcomment)
/**
    #if ($doc.comment)
        $doc.comment
    #end
*/
#end
#embedText("public class $doc.className" $doc.root.xmlLineNumber)
#embedText("    extends $doc.superClassName" $doc.root.xmlLineNumber)
#if ($doc.hasInterfaces)
    #embedText("    implements $doc.interfaceList" $doc.root.xmlLineNumber)
#end
{

##
## instance var declarations
##
#trace("    //  instance variables")
#foreach ($decl in $doc.declarationIterator)
    #if ($decl.inspectable)
        #embedText("    [Inspectable]" $decl.lineRef)
    #end
    #if (!$decl.idIsAutogenerated || $decl.bindabilityEnsured)
        #embedText("    [Bindable]" $decl.lineRef)
    #end
## NOTE: the SWC contains actual, debuggable bytecode for empty variable declarations. To avoid unwanted
## BPs in the debugger, we use an explicitly compile-error-only mapping here.
## if id is not auto generated, and if we care about comments then lets add comments to generated class
    #if (!$decl.idIsAutogenerated)
        #if ($processcomment)
        /**
            #if ($decl.comment)
                $decl.comment
            #end
        */
        #end
    #end
## if id is auto generated, lets add private to fields. 
    #if ($decl.idIsAutogenerated || !$processcomment)
    /**
    * @private
    **/
    #end
    #embedTextMapCompileErrorsOnly("    public var $decl.name : $decl.typeExpr;" $decl.lineRef)

#end

#trace("    //  type-import dummies")
#foreach ($typeName in $doc.typeRefs)
private var _typeRef$velocityCount : $typeName;
#end

##
##  construct/init
##
#if ($doc.isIUIComponent)

    #if ($doc.describeVisualChildren && $doc.isContainer)
    ##
    ## Note that we line-map this code for compile errors only. This is so that
    ## BPs set on MXML tags don't fire on startup. However, it also means that
    ## any RTEs will not point back to the defining tag.
    ##
        #trace("    //  Container document descriptor")
        #foreach ($frag in $doc.getDescriptorDeclaration("_documentDescriptor_"))
            #embedTextMapCompileErrorsOnly($frag.Text $frag.xmlLineNumber)
        #end
    #end

    #trace("    //  constructor (Flex display object)")
## if we care about comments, let the constructor be visible. 
    #if (!$processcomment)
    /**
    * @private
    **/
    #end
public function ${doc.className}()
{
super();

    #if ($doc.isContainer || $doc.isVisualElementContainer)
    ##      The _document variable needs to be set earlier than
    ##      initialize(), because children can access their
    ##      parent's document in UIComponent.executeBindings().
    mx_internal::_document = this;
    #end

    #emitBindingInitializers()
    #emitComponentInitializers_1()
    #foreach ($frag in $doc.getStatesDeclaration())
        #embedText($frag.Text $frag.xmlLineNumber)
    #end
    #emitInitialBindingExecutions()

}

    #if ($doc.isIFlexModule)
    /**
    * @private
    **/
    private var __moduleFactoryInitialized:Boolean = false;

    /**
    * @private
    * Override the module factory so we can defer setting style declarations
    * until a module factory is set. Without the correct module factory set
    * the style declaration will end up in the wrong style manager.
    **/
    override public function set moduleFactory(factory:IFlexModuleFactory):void
    {
    super.moduleFactory = factory;

    if (__moduleFactoryInitialized)
    return;

    __moduleFactoryInitialized = true;

        #emitComponentStyleInitializers()

    }
    #end

    #trace("    //  initialize()")
/**
* @private
**/
override public function initialize():void
{
    #if ($doc.describeVisualChildren && $doc.isContainer)
    ##
    ##      Note: setDocumentDescriptor() ensures that visual children are defined by
    ##      at most one documentDescriptor, as we call super.initialize() upwards through
    ##      the derivation chain. If more than one set of child descriptors is encountered,
    ##      an RTE is thrown.
    ##
    mx_internal::setDocumentDescriptor(_documentDescriptor_);
    #end
    #emitComponentInitializers_2()
super.initialize();
}
#else

##
##  non-UIComponent construct/init codegen
##  TODO this is just a placeholder for a non-UIComponent component constructor. Details entirely TBD
##

    #trace("    //  constructor (non-Flex display object)")
/**
* @private
**/
public function ${doc.className}()
{
super();

    #foreach ($frag in $doc.getStatesDeclaration())
        #embedText($frag.Text $frag.xmlLineNumber)
    #end
    #emitBindingInitializers()
    #emitComponentInitializers_1()
    #emitInitialBindingExecutions()
    #emitComponentInitializers_2()

}
#end

## If we need to initialize stage properties, then create
## a handler function for the Event.ADDED_TO_STAGE event.
#if ($doc.hasStagePropertyInitializers)
    #emitAddedToStageHandlerFunc()
#end

##
## scripts
##
#trace("    //  scripts")
#foreach ($script in $doc.scripts)
    #trace("    //
    <Script>, line $script.xmlLineNumber - $script.endXmlLineNumber")
    #embedText($script.Text $script.xmlLineNumber)

#end
#trace("    //  end scripts")

##
## initializer support defs
##
#emitInitializerSupportDefs()

##
## @Embeds
##
#trace("    //  embed carrier vars")
#foreach ($atEmbed in $doc.atEmbeds)
    #emitEmbedMetadata($atEmbed) private var $atEmbed.propName:$atEmbed.type;

#end
#trace("    //  end embed carrier vars")

##
## misc hardcoded stuff
##
#if ($doc.bindingExpressions.size() > 0)
    #trace("    //  binding management vars")
    #foreach ($var in $doc.bindingManagementVars)
        #if (!$doc.superHasPublicProperty($var.name))
        /**
         * @private
         **/
            $var.namespace var $var.name : $var.type = $var.initializer;
        #end
    #end
#end

##
## end class def
##
#trace("//  end class def")
}

##
## end package def
##
#trace("//  end package def")
}
