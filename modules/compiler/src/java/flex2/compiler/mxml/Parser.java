/* Generated By:JavaCC: Do not edit this line. Parser.java */
package flex2.compiler.mxml;

import java.lang.reflect.*;
import java.util.*;

/**
 * MXML parser: JavaCC + SAXParser as the tokenizer...
 *
 * @author Clement Wong
 */
public class Parser implements MXMLNamespaces, ParserConstants {
    private static final HashSet SPECIAL_COMPONENT_TAGS = new HashSet(8);

    static {
        SPECIAL_COMPONENT_TAGS.add("State");
        SPECIAL_COMPONENT_TAGS.add("HTTPService");
        SPECIAL_COMPONENT_TAGS.add("RemoteObject");
        SPECIAL_COMPONENT_TAGS.add("WebService");
        SPECIAL_COMPONENT_TAGS.add("method");
        SPECIAL_COMPONENT_TAGS.add("arguments");
        SPECIAL_COMPONENT_TAGS.add("operation");
        SPECIAL_COMPONENT_TAGS.add("request");
    }

    private static final HashSet FXG_LANGUAGE_TAGS = new HashSet(3);

    static {
        FXG_LANGUAGE_TAGS.add("Definition");
        FXG_LANGUAGE_TAGS.add("Library");
        FXG_LANGUAGE_TAGS.add("Private");
    }

    private static final HashSet MXML2009_NEW_TAGS = new HashSet(6);

    static {
        MXML2009_NEW_TAGS.add("Declarations");
        MXML2009_NEW_TAGS.add("Definition");
        MXML2009_NEW_TAGS.add("DesignLayer");
        MXML2009_NEW_TAGS.add("Library");
        MXML2009_NEW_TAGS.add("Private");
        MXML2009_NEW_TAGS.add("Reparent");
    }

    private static final Map ConstantMappings = new HashMap();

    static {
        // FIXME: HACK for the Apache Port.  The version of javacc.jar that was being used is ancient and is no longer available.
        // Some time over the years the format of some of the tokenImage strings in the generated file ParserConstants changed 
        // from, for example, "Script" to "\"Script\"" and "/Script" to "\"/Script\"".  If there are quotes, strip them off so 
        // that the rest of this code continues to work with no additional changes needed.
        for (int j = 0, length = ParserConstants.tokenImage.length; j < length; j++) {
            String image = ParserConstants.tokenImage[j];
            if (image.length() >= 2 && image.charAt(0) == '\u005c"' && image.charAt(image.length() - 1) == '\u005c"')
                ParserConstants.tokenImage[j] = image.substring(1, image.length() - 1);
        }

        // C: This static initializer fixes the token ids to match the index of
        //    their corresponding token strings in tokenImage.
        Field[] fields = ParserConstants.class.getFields();
        for (int i = 0, count = fields.length; i < count; i++) {
            try {
                String name = fields[i].getName();

                if (!"tokenImage".equals(name)) {
                    int value = fields[i].getInt(ParserConstants.class);
                    for (int j = 0, length = ParserConstants.tokenImage.length; j < length; j++) {
                        String image = ParserConstants.tokenImage[j];
                        switch (image.charAt(0)) {
                            case '<':
                                image = image.substring(1, image.length() - 1);
                                break;
                            case '/':
                                image = "END_" + image.substring(1).toUpperCase();
                                break;
                            default:
                                image = "START_" + image.toUpperCase();
                        }

                        if ("START_ELEMENT".equals(image) || "END_ELEMENT".equals(image)) {
                            ParserConstants.tokenImage[j] = "Non-MXML language element";
                        }

                        if (image.equals(name)) {
                            String temp = ParserConstants.tokenImage[value];
                            ParserConstants.tokenImage[value] = ParserConstants.tokenImage[j];
                            ParserConstants.tokenImage[j] = temp;
                            ConstantMappings.put(ParserConstants.tokenImage[value], new Integer(value));
                            break;
                        }
                    }
                }
            } catch (IllegalAccessException ex) {
                ex.printStackTrace();
            }
        }
    }

    public static final int findElementType(String uri, String localName, boolean isStart) {
        if (MXML_2009_NAMESPACE.equals(uri) &&
                !SPECIAL_COMPONENT_TAGS.contains(localName)) {
            String localPart = (isStart) ? localName : "/" + localName;
            if (ConstantMappings.containsKey(localPart)) {
                return ((Integer) ConstantMappings.get(localPart)).intValue();
            }
        } else if (MXML_2006_NAMESPACE.equals(uri) &&
                !MXML2009_NEW_TAGS.contains(localName)) {
            String localPart = (isStart) ? localName : "/" + localName;
            if (ConstantMappings.containsKey(localPart)) {
                return ((Integer) ConstantMappings.get(localPart)).intValue();
            }
        } else if (FXG_2008_NAMESPACE.equals(uri) &&
                FXG_LANGUAGE_TAGS.contains(localName)) {
            String localPart = (isStart) ? localName : "/" + localName;
            if (ConstantMappings.containsKey(localPart)) {
                return ((Integer) ConstantMappings.get(localPart)).intValue();
            }
        } else if ((SPARK_NAMESPACE.equals(uri) || MX_NAMESPACE.equals(uri)) &&
                SPECIAL_COMPONENT_TAGS.contains(localName)) {
            String localPart = (isStart) ? localName : "/" + localName;
            if (ConstantMappings.containsKey(localPart)) {
                return ((Integer) ConstantMappings.get(localPart)).intValue();
            }
        }

        return (isStart) ? ParserConstants.START_ELEMENT : ParserConstants.END_ELEMENT;
    }

    /**
     * Set a visitor implementation, e.g. SyntaxAnalyzer
     */
    public void setVisitor(MxmlVisitor v) {
        visitor = v;
    }

    private MxmlVisitor visitor;

    // Helper function: Lazy instantiation of List.
    private static final List addChild(List children, Token child) {
        if (children == null) {
            children = new ArrayList();
        }
        children.add(child);

        return children;
    }

    // Helper function: Lazy instantiation of Map.
    private static final Map addAttribute(Map attributes, Token name, Token value) {
        if (attributes == null) {
            attributes = new HashMap();
        }
        attributes.put(name, value);

        return attributes;
    }

    final public Token parseApplication() throws ParseException {
        Token t;
        t = parseApplicationComponent();
        jj_consume_token(0);
        {
            if (true) return t;
        }
        throw new Error("Missing return statement in function");
    }

    final public Token parseApplicationComponent() throws ParseException {
        Token app, child;
        List children = null;
        app = jj_consume_token(START_ELEMENT);
        label_1:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case START_DESIGNLAYER:
                case START_DECLARATIONS:
                case START_STYLE:
                case START_SCRIPT:
                case START_METADATA:
                case START_STATE:
                case START_MODEL:
                case START_XML:
                case START_XMLLIST:
                case START_ARRAY:
                case START_VECTOR:
                case START_BINDING:
                case START_STRING:
                case START_NUMBER:
                case START_INT:
                case START_UINT:
                case START_BOOLEAN:
                case START_CLASS:
                case START_FUNCTION:
                case START_REMOTEOBJECT:
                case START_WEBSERVICE:
                case START_HTTPSERVICE:
                case START_COMPONENT:
                case START_REPARENT:
                case START_PRIVATE:
                case START_LIBRARY:
                case START_ELEMENT:
                case CDATA:
                    ;
                    break;
                default:
                    jj_la1[0] = jj_gen;
                    break label_1;
            }
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case CDATA:
                    child = jj_consume_token(CDATA);
                    break;
                case START_DESIGNLAYER:
                    child = parseDesignLayer();
                    break;
                case START_STYLE:
                case START_SCRIPT:
                case START_METADATA:
                    child = parseLanguageComponent();
                    break;
                case START_DECLARATIONS:
                    child = parseDeclarations();
                    break;
                case START_LIBRARY:
                    child = parseLibrary();
                    break;
                case START_REMOTEOBJECT:
                case START_WEBSERVICE:
                case START_HTTPSERVICE:
                    child = parseServiceComponent();
                    break;
                case START_STATE:
                case START_MODEL:
                case START_XML:
                case START_XMLLIST:
                case START_ARRAY:
                case START_VECTOR:
                case START_BINDING:
                case START_STRING:
                case START_NUMBER:
                case START_INT:
                case START_UINT:
                case START_BOOLEAN:
                case START_CLASS:
                case START_FUNCTION:
                case START_COMPONENT:
                case START_REPARENT:
                    child = parseFacelessComponent();
                    break;
                case START_ELEMENT:
                    child = parseUIComponent();
                    break;
                case START_PRIVATE:
                    child = parsePrivate();
                    break;
                default:
                    jj_la1[1] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
            children = addChild(children, child);
        }
        jj_consume_token(END_ELEMENT);
        if (visitor != null) {
            visitor.parseApplication(app, children);
        }
        {
            if (true) return app;
        }
        throw new Error("Missing return statement in function");
    }

    final public Token parseUIComponent() throws ParseException {
        Token comp, child;
        List children = null;
        comp = jj_consume_token(START_ELEMENT);
        label_2:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case START_DESIGNLAYER:
                case START_STYLE:
                case START_SCRIPT:
                case START_METADATA:
                case START_STATE:
                case START_MODEL:
                case START_XML:
                case START_XMLLIST:
                case START_ARRAY:
                case START_VECTOR:
                case START_BINDING:
                case START_STRING:
                case START_NUMBER:
                case START_INT:
                case START_UINT:
                case START_BOOLEAN:
                case START_CLASS:
                case START_FUNCTION:
                case START_COMPONENT:
                case START_REPARENT:
                case START_ELEMENT:
                case CDATA:
                    ;
                    break;
                default:
                    jj_la1[2] = jj_gen;
                    break label_2;
            }
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case CDATA:
                    child = jj_consume_token(CDATA);
                    break;
                case START_DESIGNLAYER:
                    child = parseDesignLayer();
                    break;
                case START_STYLE:
                case START_SCRIPT:
                case START_METADATA:
                    child = parseLanguageComponent();
                    break;
                case START_STATE:
                case START_MODEL:
                case START_XML:
                case START_XMLLIST:
                case START_ARRAY:
                case START_VECTOR:
                case START_BINDING:
                case START_STRING:
                case START_NUMBER:
                case START_INT:
                case START_UINT:
                case START_BOOLEAN:
                case START_CLASS:
                case START_FUNCTION:
                case START_COMPONENT:
                case START_REPARENT:
                    child = parseFacelessComponent();
                    break;
                case START_ELEMENT:
                    child = parseUIComponent();
                    break;
                default:
                    jj_la1[3] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
            children = addChild(children, child);
        }
        jj_consume_token(END_ELEMENT);
        if (visitor != null) {
            visitor.parseComponent(comp, children);
        }
        {
            if (true) return comp;
        }
        throw new Error("Missing return statement in function");
    }

    final public Token parseDesignLayer() throws ParseException {
        Token t, child;
        List children = null;
        t = jj_consume_token(START_DESIGNLAYER);
        label_3:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case START_DESIGNLAYER:
                case START_STYLE:
                case START_SCRIPT:
                case START_METADATA:
                case START_STATE:
                case START_MODEL:
                case START_XML:
                case START_XMLLIST:
                case START_ARRAY:
                case START_VECTOR:
                case START_BINDING:
                case START_STRING:
                case START_NUMBER:
                case START_INT:
                case START_UINT:
                case START_BOOLEAN:
                case START_CLASS:
                case START_FUNCTION:
                case START_COMPONENT:
                case START_REPARENT:
                case START_ELEMENT:
                case CDATA:
                    ;
                    break;
                default:
                    jj_la1[4] = jj_gen;
                    break label_3;
            }
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case CDATA:
                    child = jj_consume_token(CDATA);
                    break;
                case START_DESIGNLAYER:
                    child = parseDesignLayer();
                    break;
                case START_STYLE:
                case START_SCRIPT:
                case START_METADATA:
                    child = parseLanguageComponent();
                    break;
                case START_STATE:
                case START_MODEL:
                case START_XML:
                case START_XMLLIST:
                case START_ARRAY:
                case START_VECTOR:
                case START_BINDING:
                case START_STRING:
                case START_NUMBER:
                case START_INT:
                case START_UINT:
                case START_BOOLEAN:
                case START_CLASS:
                case START_FUNCTION:
                case START_COMPONENT:
                case START_REPARENT:
                    child = parseFacelessComponent();
                    break;
                case START_ELEMENT:
                    child = parseUIComponent();
                    break;
                default:
                    jj_la1[5] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
            children = addChild(children, child);
        }
        jj_consume_token(END_DESIGNLAYER);
        if (visitor != null) {
            visitor.parseDesignLayer(t, children);
        }
        {
            if (true) return t;
        }
        throw new Error("Missing return statement in function");
    }

    final public Token parseLanguageComponent() throws ParseException {
        Token t;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case START_METADATA:
                t = parseMetaData();
                break;
            case START_SCRIPT:
                t = parseScript();
                break;
            case START_STYLE:
                t = parseStyle();
                break;
            default:
                jj_la1[6] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        {
            if (true) return t;
        }
        throw new Error("Missing return statement in function");
    }

    final public Token parseDeclarations() throws ParseException {
        Token t, child;
        List children = null;
        t = jj_consume_token(START_DECLARATIONS);
        label_4:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case START_DESIGNLAYER:
                case START_STATE:
                case START_MODEL:
                case START_XML:
                case START_XMLLIST:
                case START_ARRAY:
                case START_VECTOR:
                case START_BINDING:
                case START_STRING:
                case START_NUMBER:
                case START_INT:
                case START_UINT:
                case START_BOOLEAN:
                case START_CLASS:
                case START_FUNCTION:
                case START_REMOTEOBJECT:
                case START_WEBSERVICE:
                case START_HTTPSERVICE:
                case START_COMPONENT:
                case START_REPARENT:
                case START_ELEMENT:
                    ;
                    break;
                default:
                    jj_la1[7] = jj_gen;
                    break label_4;
            }
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case START_REMOTEOBJECT:
                case START_WEBSERVICE:
                case START_HTTPSERVICE:
                    child = parseServiceComponent();
                    break;
                case START_STATE:
                case START_MODEL:
                case START_XML:
                case START_XMLLIST:
                case START_ARRAY:
                case START_VECTOR:
                case START_BINDING:
                case START_STRING:
                case START_NUMBER:
                case START_INT:
                case START_UINT:
                case START_BOOLEAN:
                case START_CLASS:
                case START_FUNCTION:
                case START_COMPONENT:
                case START_REPARENT:
                    child = parseFacelessComponent();
                    break;
                case START_ELEMENT:
                    child = parseUIComponent();
                    break;
                case START_DESIGNLAYER:
                    child = parseDesignLayer();
                    break;
                default:
                    jj_la1[8] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
            children = addChild(children, child);
        }
        jj_consume_token(END_DECLARATIONS);
        if (visitor != null) {
            visitor.parseDeclarations(t, children);
        }
        {
            if (true) return t;
        }
        throw new Error("Missing return statement in function");
    }

    final public Token parseServiceComponent() throws ParseException {
        Token t;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case START_WEBSERVICE:
                t = parseWebService();
                break;
            case START_HTTPSERVICE:
                t = parseHTTPService();
                break;
            case START_REMOTEOBJECT:
                t = parseRemoteObject();
                break;
            default:
                jj_la1[9] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        {
            if (true) return t;
        }
        throw new Error("Missing return statement in function");
    }

    final public Token parseStyle() throws ParseException {
        Token t, d = null;
        t = jj_consume_token(START_STYLE);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case CDATA:
                d = jj_consume_token(CDATA);
                break;
            default:
                jj_la1[10] = jj_gen;
                ;
        }
        jj_consume_token(END_STYLE);
        if (visitor != null) {
            visitor.parseStyle(t, d);
        }
        {
            if (true) return t;
        }
        throw new Error("Missing return statement in function");
    }

    final public Token parseScript() throws ParseException {
        Token t, d = null;
        t = jj_consume_token(START_SCRIPT);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case CDATA:
                d = jj_consume_token(CDATA);
                break;
            default:
                jj_la1[11] = jj_gen;
                ;
        }
        jj_consume_token(END_SCRIPT);
        if (visitor != null) {
            visitor.parseScript(t, d);
        }
        {
            if (true) return t;
        }
        throw new Error("Missing return statement in function");
    }

    final public Token parseMetaData() throws ParseException {
        Token t, d = null;
        t = jj_consume_token(START_METADATA);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case CDATA:
                d = jj_consume_token(CDATA);
                break;
            default:
                jj_la1[12] = jj_gen;
                ;
        }
        jj_consume_token(END_METADATA);
        if (visitor != null) {
            visitor.parseMetaData(t, d);
        }
        {
            if (true) return t;
        }
        throw new Error("Missing return statement in function");
    }

    final public Token parseFacelessComponent() throws ParseException {
        Token t;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case START_MODEL:
                t = parseModel();
                break;
            case START_XML:
                t = parseXML();
                break;
            case START_XMLLIST:
                t = parseXMLList();
                break;
            case START_ARRAY:
                t = parseArray();
                break;
            case START_VECTOR:
                t = parseVector();
                break;
            case START_BINDING:
                t = parseBinding();
                break;
            case START_STRING:
            case START_NUMBER:
            case START_INT:
            case START_UINT:
            case START_BOOLEAN:
            case START_CLASS:
            case START_FUNCTION:
                t = parsePrimitive();
                break;
            case START_COMPONENT:
                t = parseInlineComponent();
                break;
            case START_STATE:
                t = parseState();
                break;
            case START_REPARENT:
                t = parseReparent();
                break;
            default:
                jj_la1[13] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        {
            if (true) return t;
        }
        throw new Error("Missing return statement in function");
    }

    final public Token parseState() throws ParseException {
        Token t, child;
        List children = null;
        t = jj_consume_token(START_STATE);
        label_5:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case START_DESIGNLAYER:
                case START_STATE:
                case START_MODEL:
                case START_XML:
                case START_XMLLIST:
                case START_ARRAY:
                case START_VECTOR:
                case START_BINDING:
                case START_STRING:
                case START_NUMBER:
                case START_INT:
                case START_UINT:
                case START_BOOLEAN:
                case START_CLASS:
                case START_FUNCTION:
                case START_COMPONENT:
                case START_REPARENT:
                case START_ELEMENT:
                    ;
                    break;
                default:
                    jj_la1[14] = jj_gen;
                    break label_5;
            }
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case START_DESIGNLAYER:
                    child = parseDesignLayer();
                    break;
                case START_STATE:
                case START_MODEL:
                case START_XML:
                case START_XMLLIST:
                case START_ARRAY:
                case START_VECTOR:
                case START_BINDING:
                case START_STRING:
                case START_NUMBER:
                case START_INT:
                case START_UINT:
                case START_BOOLEAN:
                case START_CLASS:
                case START_FUNCTION:
                case START_COMPONENT:
                case START_REPARENT:
                    child = parseFacelessComponent();
                    break;
                case START_ELEMENT:
                    child = parseUIComponent();
                    break;
                default:
                    jj_la1[15] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
            children = addChild(children, child);
        }
        jj_consume_token(END_STATE);
        if (visitor != null) {
            visitor.parseState(t, children);
        }
        {
            if (true) return t;
        }
        throw new Error("Missing return statement in function");
    }

    final public Token parseModel() throws ParseException {
        Token t, obj = null;
        List children = null;
        t = jj_consume_token(START_MODEL);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case CDATA:
                obj = jj_consume_token(CDATA);
                children = addChild(children, obj);
                break;
            default:
                jj_la1[18] = jj_gen;
                label_6:
                while (true) {
                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                        case START_ARRAY:
                        case START_VECTOR:
                        case START_STRING:
                        case START_NUMBER:
                        case START_INT:
                        case START_UINT:
                        case START_BOOLEAN:
                        case START_CLASS:
                        case START_FUNCTION:
                        case START_ELEMENT:
                            ;
                            break;
                        default:
                            jj_la1[16] = jj_gen;
                            break label_6;
                    }
                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                        case START_STRING:
                        case START_NUMBER:
                        case START_INT:
                        case START_UINT:
                        case START_BOOLEAN:
                        case START_CLASS:
                        case START_FUNCTION:
                            obj = parsePrimitive();
                            break;
                        case START_ARRAY:
                            obj = parseArray();
                            break;
                        case START_VECTOR:
                            obj = parseVector();
                            break;
                        case START_ELEMENT:
                            obj = parseAnonymousObject();
                            break;
                        default:
                            jj_la1[17] = jj_gen;
                            jj_consume_token(-1);
                            throw new ParseException();
                    }
                    children = addChild(children, obj);
                }
        }
        jj_consume_token(END_MODEL);
        if (visitor != null) {
            visitor.parseModel(t, children);
        }
        {
            if (true) return t;
        }
        throw new Error("Missing return statement in function");
    }

    final public Token parseXML() throws ParseException {
        Token t, obj = null;
        List children = null;
        t = jj_consume_token(START_XML);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case CDATA:
                obj = jj_consume_token(CDATA);
                children = addChild(children, obj);
                break;
            default:
                jj_la1[20] = jj_gen;
                label_7:
                while (true) {
                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                        case START_ELEMENT:
                            ;
                            break;
                        default:
                            jj_la1[19] = jj_gen;
                            break label_7;
                    }
                    obj = parseAnonymousObject();
                    children = addChild(children, obj);
                }
        }
        jj_consume_token(END_XML);
        if (visitor != null) {
            visitor.parseXML(t, children);
        }
        {
            if (true) return t;
        }
        throw new Error("Missing return statement in function");
    }

    final public Token parseXMLList() throws ParseException {
        Token t, obj = null;
        List children = null;
        t = jj_consume_token(START_XMLLIST);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case CDATA:
                obj = jj_consume_token(CDATA);
                children = addChild(children, obj);
                break;
            default:
                jj_la1[22] = jj_gen;
                label_8:
                while (true) {
                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                        case START_ELEMENT:
                            ;
                            break;
                        default:
                            jj_la1[21] = jj_gen;
                            break label_8;
                    }
                    obj = parseAnonymousObject();
                    children = addChild(children, obj);
                }
        }
        jj_consume_token(END_XMLLIST);
        if (visitor != null) {
            visitor.parseXMLList(t, children);
        }
        {
            if (true) return t;
        }
        throw new Error("Missing return statement in function");
    }

    final public Token parseArray() throws ParseException {
        Token t, obj = null;
        List children = null;
        t = jj_consume_token(START_ARRAY);
        label_9:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case START_DESIGNLAYER:
                case START_STATE:
                case START_ARRAY:
                case START_VECTOR:
                case START_STRING:
                case START_NUMBER:
                case START_INT:
                case START_UINT:
                case START_BOOLEAN:
                case START_CLASS:
                case START_FUNCTION:
                case START_REPARENT:
                case START_ELEMENT:
                case CDATA:
                    ;
                    break;
                default:
                    jj_la1[23] = jj_gen;
                    break label_9;
            }
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case CDATA:
                    obj = jj_consume_token(CDATA);
                    break;
                case START_DESIGNLAYER:
                    obj = parseDesignLayer();
                    break;
                case START_STRING:
                case START_NUMBER:
                case START_INT:
                case START_UINT:
                case START_BOOLEAN:
                case START_CLASS:
                case START_FUNCTION:
                    obj = parsePrimitive();
                    break;
                case START_ARRAY:
                    obj = parseArray();
                    break;
                case START_VECTOR:
                    obj = parseVector();
                    break;
                case START_ELEMENT:
                    obj = parseUIComponent();
                    break;
                case START_REPARENT:
                    obj = parseReparent();
                    break;
                case START_STATE:
                    obj = parseState();
                    break;
                default:
                    jj_la1[24] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
            children = addChild(children, obj);
        }
        jj_consume_token(END_ARRAY);
        if (visitor != null) {
            visitor.parseArray(t, children);
        }
        {
            if (true) return t;
        }
        throw new Error("Missing return statement in function");
    }

    final public Token parseVector() throws ParseException {
        Token t, obj = null;
        List children = null;
        t = jj_consume_token(START_VECTOR);
        label_10:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case START_DESIGNLAYER:
                case START_STATE:
                case START_ARRAY:
                case START_VECTOR:
                case START_STRING:
                case START_NUMBER:
                case START_INT:
                case START_UINT:
                case START_BOOLEAN:
                case START_CLASS:
                case START_FUNCTION:
                case START_REPARENT:
                case START_ELEMENT:
                case CDATA:
                    ;
                    break;
                default:
                    jj_la1[25] = jj_gen;
                    break label_10;
            }
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case CDATA:
                    obj = jj_consume_token(CDATA);
                    break;
                case START_DESIGNLAYER:
                    obj = parseDesignLayer();
                    break;
                case START_STRING:
                case START_NUMBER:
                case START_INT:
                case START_UINT:
                case START_BOOLEAN:
                case START_CLASS:
                case START_FUNCTION:
                    obj = parsePrimitive();
                    break;
                case START_ARRAY:
                    obj = parseArray();
                    break;
                case START_VECTOR:
                    obj = parseVector();
                    break;
                case START_ELEMENT:
                    obj = parseUIComponent();
                    break;
                case START_REPARENT:
                    obj = parseReparent();
                    break;
                case START_STATE:
                    obj = parseState();
                    break;
                default:
                    jj_la1[26] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
            children = addChild(children, obj);
        }
        jj_consume_token(END_VECTOR);
        if (visitor != null) {
            visitor.parseVector(t, children);
        }
        {
            if (true) return t;
        }
        throw new Error("Missing return statement in function");
    }

    final public Token parseBinding() throws ParseException {
        Token t;
        t = jj_consume_token(START_BINDING);
        jj_consume_token(END_BINDING);
        if (visitor != null) {
            visitor.parseBinding(t);
        }
        {
            if (true) return t;
        }
        throw new Error("Missing return statement in function");
    }

    final public Token parseAnonymousObject() throws ParseException {
        Token t, obj = null;
        List children = null;
        t = jj_consume_token(START_ELEMENT);
        label_11:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case START_ELEMENT:
                case CDATA:
                    ;
                    break;
                default:
                    jj_la1[27] = jj_gen;
                    break label_11;
            }
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case CDATA:
                    obj = jj_consume_token(CDATA);
                    break;
                case START_ELEMENT:
                    obj = parseAnonymousObject();
                    break;
                default:
                    jj_la1[28] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
            children = addChild(children, obj);
        }
        jj_consume_token(END_ELEMENT);
        if (visitor != null) {
            visitor.parseAnonymousObject(t, children);
        }
        {
            if (true) return t;
        }
        throw new Error("Missing return statement in function");
    }

    final public Token parsePrimitive() throws ParseException {
        Token t;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case START_STRING:
                t = parseString();
                break;
            case START_NUMBER:
                t = parseNumber();
                break;
            case START_INT:
                t = parseInt();
                break;
            case START_UINT:
                t = parseUInt();
                break;
            case START_BOOLEAN:
                t = parseBoolean();
                break;
            case START_CLASS:
                t = parseClass();
                break;
            case START_FUNCTION:
                t = parseFunction();
                break;
            default:
                jj_la1[29] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        {
            if (true) return t;
        }
        throw new Error("Missing return statement in function");
    }

    final public Token parseString() throws ParseException {
        Token t, data = null;
        t = jj_consume_token(START_STRING);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case CDATA:
                data = jj_consume_token(CDATA);
                break;
            default:
                jj_la1[30] = jj_gen;
                ;
        }
        jj_consume_token(END_STRING);
        if (visitor != null) {
            visitor.parseString(t, data);
        }
        {
            if (true) return t;
        }
        throw new Error("Missing return statement in function");
    }

    final public Token parseNumber() throws ParseException {
        Token t, data = null;
        t = jj_consume_token(START_NUMBER);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case CDATA:
                data = jj_consume_token(CDATA);
                break;
            default:
                jj_la1[31] = jj_gen;
                ;
        }
        jj_consume_token(END_NUMBER);
        if (visitor != null) {
            visitor.parseNumber(t, data);
        }
        {
            if (true) return t;
        }
        throw new Error("Missing return statement in function");
    }

    final public Token parseInt() throws ParseException {
        Token t, data = null;
        t = jj_consume_token(START_INT);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case CDATA:
                data = jj_consume_token(CDATA);
                break;
            default:
                jj_la1[32] = jj_gen;
                ;
        }
        jj_consume_token(END_INT);
        if (visitor != null) {
            visitor.parseInt(t, data);
        }
        {
            if (true) return t;
        }
        throw new Error("Missing return statement in function");
    }

    final public Token parseUInt() throws ParseException {
        Token t, data = null;
        t = jj_consume_token(START_UINT);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case CDATA:
                data = jj_consume_token(CDATA);
                break;
            default:
                jj_la1[33] = jj_gen;
                ;
        }
        jj_consume_token(END_UINT);
        if (visitor != null) {
            visitor.parseUInt(t, data);
        }
        {
            if (true) return t;
        }
        throw new Error("Missing return statement in function");
    }

    final public Token parseBoolean() throws ParseException {
        Token t, data = null;
        t = jj_consume_token(START_BOOLEAN);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case CDATA:
                data = jj_consume_token(CDATA);
                break;
            default:
                jj_la1[34] = jj_gen;
                ;
        }
        jj_consume_token(END_BOOLEAN);
        if (visitor != null) {
            visitor.parseBoolean(t, data);
        }
        {
            if (true) return t;
        }
        throw new Error("Missing return statement in function");
    }

    final public Token parseClass() throws ParseException {
        Token t, data = null;
        t = jj_consume_token(START_CLASS);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case CDATA:
                data = jj_consume_token(CDATA);
                break;
            default:
                jj_la1[35] = jj_gen;
                ;
        }
        jj_consume_token(END_CLASS);
        if (visitor != null) {
            visitor.parseClass(t, data);
        }
        {
            if (true) return t;
        }
        throw new Error("Missing return statement in function");
    }

    final public Token parseFunction() throws ParseException {
        Token t, data = null;
        t = jj_consume_token(START_FUNCTION);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case CDATA:
                data = jj_consume_token(CDATA);
                break;
            default:
                jj_la1[36] = jj_gen;
                ;
        }
        jj_consume_token(END_FUNCTION);
        if (visitor != null) {
            visitor.parseFunction(t, data);
        }
        {
            if (true) return t;
        }
        throw new Error("Missing return statement in function");
    }

/**
 *
 * SERVICE TAGS
 *
 */

    /**
     * <mx:RemoteObject/>
     * Special child tag type <mx:method/>.
     */
    final public Token parseRemoteObject() throws ParseException {
        Token t, child;
        List children = null;
        t = jj_consume_token(START_REMOTEOBJECT);
        label_12:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case START_METHOD:
                case START_ELEMENT:
                    ;
                    break;
                default:
                    jj_la1[37] = jj_gen;
                    break label_12;
            }
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case START_METHOD:
                    child = parseMethod();
                    break;
                case START_ELEMENT:
                    child = parseUIComponent();
                    break;
                default:
                    jj_la1[38] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
            children = addChild(children, child);
        }
        jj_consume_token(END_REMOTEOBJECT);
        if (visitor != null) {
            visitor.parseRemoteObject(t, children);
        }
        {
            if (true) return t;
        }
        throw new Error("Missing return statement in function");
    }

    /**
     * <mx:RemoteObject>/<mx:method/>.
     * Special child tag type <mx:arguments/>.
     */
    final public Token parseMethod() throws ParseException {
        Token t, child;
        List children = null;
        t = jj_consume_token(START_METHOD);
        label_13:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case START_ARGUMENTS:
                case START_ELEMENT:
                    ;
                    break;
                default:
                    jj_la1[39] = jj_gen;
                    break label_13;
            }
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case START_ARGUMENTS:
                    child = parseArguments();
                    break;
                case START_ELEMENT:
                    child = parseUIComponent();
                    break;
                default:
                    jj_la1[40] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
            children = addChild(children, child);
        }
        jj_consume_token(END_METHOD);
        if (visitor != null) {
            visitor.parseMethod(t, children);
        }
        {
            if (true) return t;
        }
        throw new Error("Missing return statement in function");
    }

    /**
     * <mx:RemoteObject>/<mx:method>/<mx:arguments/>
     * Parsed as an anonymous object.
     * TODO: add metadata-driven ability to parse any property-initializing child tag as a key/value map.
     * BUT NOTE that in this particular use case, we *also* save argument order (see RemoteObjectBuilder).
     * So to be completely free of special processing, we'd need to add that as a metadata-triggered option as well.
     */
    final public Token parseArguments() throws ParseException {
        Token t, child = null;
        List children = null;
        t = jj_consume_token(START_ARGUMENTS);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case CDATA:
                child = jj_consume_token(CDATA);
                children = addChild(children, child);
                break;
            default:
                jj_la1[43] = jj_gen;
                label_14:
                while (true) {
                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                        case START_ARRAY:
                        case START_STRING:
                        case START_NUMBER:
                        case START_INT:
                        case START_UINT:
                        case START_BOOLEAN:
                        case START_CLASS:
                        case START_FUNCTION:
                        case START_ELEMENT:
                            ;
                            break;
                        default:
                            jj_la1[41] = jj_gen;
                            break label_14;
                    }
                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                        case START_STRING:
                        case START_NUMBER:
                        case START_INT:
                        case START_UINT:
                        case START_BOOLEAN:
                        case START_CLASS:
                        case START_FUNCTION:
                            // LOOKAHEAD ( { "true".equals(((Element) token).getAttribute("literal")) } )
                            //    child = parseXML() |
                            child = parsePrimitive();
                            break;
                        case START_ARRAY:
                            child = parseArray();
                            break;
                        case START_ELEMENT:
                            child = parseAnonymousObject();
                            break;
                        default:
                            jj_la1[42] = jj_gen;
                            jj_consume_token(-1);
                            throw new ParseException();
                    }
                    children = addChild(children, child);
                }
        }
        jj_consume_token(END_ARGUMENTS);
        if (visitor != null) {
            visitor.parseArguments(t, children);
        }
        {
            if (true) return t;
        }
        throw new Error("Missing return statement in function");
    }

    /**
     * <mx:WebService/>
     * Special child tag type <mx:operation/>.
     */
    final public Token parseWebService() throws ParseException {
        Token t, child;
        List children = null;
        t = jj_consume_token(START_WEBSERVICE);
        label_15:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case START_OPERATION:
                case START_ELEMENT:
                    ;
                    break;
                default:
                    jj_la1[44] = jj_gen;
                    break label_15;
            }
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case START_OPERATION:
                    child = parseOperation();
                    break;
                case START_ELEMENT:
                    child = parseUIComponent();
                    break;
                default:
                    jj_la1[45] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
            children = addChild(children, child);
        }
        jj_consume_token(END_WEBSERVICE);
        if (visitor != null) {
            visitor.parseWebService(t, children);
        }
        {
            if (true) return t;
        }
        throw new Error("Missing return statement in function");
    }

    /**
     * <mx:WebService>/<mx:operation/>.
     * Special child tag type <mx:request/>.
     * Note: at most one <mx:request/> child may be specified - this is enforced downstream.
     */
    final public Token parseOperation() throws ParseException {
        Token t, child;
        List children = null;
        t = jj_consume_token(START_OPERATION);
        label_16:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case START_REQUEST:
                case START_ELEMENT:
                    ;
                    break;
                default:
                    jj_la1[46] = jj_gen;
                    break label_16;
            }
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case START_REQUEST:
                    child = parseRequest();
                    break;
                case START_ELEMENT:
                    child = parseUIComponent();
                    break;
                default:
                    jj_la1[47] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
            children = addChild(children, child);
        }
        jj_consume_token(END_OPERATION);
        if (visitor != null) {
            visitor.parseOperation(t, children);
        }
        {
            if (true) return t;
        }
        throw new Error("Missing return statement in function");
    }

    /**
     * <mx:WebService>/<mx:operation>/<mx:request/> and <mx:HTTPService>/<mx:request/>.
     * Parsed as an anonymous object.
     * TODO: add metadata-driven ability to parse any property-initializing child tag as a key/value map.
     */
    final public Token parseRequest() throws ParseException {
        Token t, child = null;
        List children = null;
        t = jj_consume_token(START_REQUEST);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case CDATA:
                child = jj_consume_token(CDATA);
                children = addChild(children, child);
                break;
            default:
                jj_la1[49] = jj_gen;
                label_17:
                while (true) {
                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                        case START_ELEMENT:
                            ;
                            break;
                        default:
                            jj_la1[48] = jj_gen;
                            break label_17;
                    }
                    // LOOKAHEAD ( { "literal".equals(((Element) token).getAttribute("format")) ||
                    //              "xml".equals(((Element) token).getAttribute("format")) } )
                    //    child = parseXML() |
                    child = parseAnonymousObject();
                    children = addChild(children, child);
                }
        }
        jj_consume_token(END_REQUEST);
        if (visitor != null) {
            visitor.parseRequest(t, children);
        }
        {
            if (true) return t;
        }
        throw new Error("Missing return statement in function");
    }

    /**
     * <mx:HTTPService/>
     * Special child tag type <mx:request/>.
     * Note: at most one <mx:request/> child may be specified - this is enforced downstream.
     */
    final public Token parseHTTPService() throws ParseException {
        Token t, child;
        List children = null;
        t = jj_consume_token(START_HTTPSERVICE);
        label_18:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case START_REQUEST:
                case START_ELEMENT:
                    ;
                    break;
                default:
                    jj_la1[50] = jj_gen;
                    break label_18;
            }
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case START_REQUEST:
                    child = parseRequest();
                    break;
                case START_ELEMENT:
                    child = parseUIComponent();
                    break;
                default:
                    jj_la1[51] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
            children = addChild(children, child);
        }
        jj_consume_token(END_HTTPSERVICE);
        if (visitor != null) {
            visitor.parseHTTPService(t, children);
        }
        {
            if (true) return t;
        }
        throw new Error("Missing return statement in function");
    }

/**
 *
 * END SERVICE TAGS
 *
 */

    /**
     *
     */
    final public Token parseInlineComponent() throws ParseException {
        Token comp, child = null;
        comp = jj_consume_token(START_COMPONENT);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case START_DESIGNLAYER:
            case START_ELEMENT:
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case START_DESIGNLAYER:
                        child = parseDesignLayer();
                        break;
                    case START_ELEMENT:
                        child = parseApplicationComponent();
                        break;
                    default:
                        jj_la1[52] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
                break;
            default:
                jj_la1[53] = jj_gen;
                ;
        }
        jj_consume_token(END_COMPONENT);
        if (visitor != null) {
            visitor.parseInlineComponent(comp, child);
        }
        {
            if (true) return comp;
        }
        throw new Error("Missing return statement in function");
    }

    /**
     *
     */
    final public Token parseReparent() throws ParseException {
        Token t;
        t = jj_consume_token(START_REPARENT);
        jj_consume_token(END_REPARENT);
        if (visitor != null) {
            visitor.parseReparent(t);
        }
        {
            if (true) return t;
        }
        throw new Error("Missing return statement in function");
    }

    /**
     * Start of tags in both MXML and FXG namespaces.
     */
    final public Token parsePrivate() throws ParseException {
        Token t;
        t = jj_consume_token(START_PRIVATE);
        label_19:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case CDATA:
                case SKIP_ELEMENT:
                    ;
                    break;
                default:
                    jj_la1[54] = jj_gen;
                    break label_19;
            }
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case SKIP_ELEMENT:
                    jj_consume_token(SKIP_ELEMENT);
                    break;
                case CDATA:
                    jj_consume_token(CDATA);
                    break;
                default:
                    jj_la1[55] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
        }
        jj_consume_token(END_PRIVATE);
        {
            if (true) return t;
        }
        throw new Error("Missing return statement in function");
    }

    /**
     * <Library> tag
     * Special child tag <Definition />
     * May have zero or more child Definitions.
     */
    final public Token parseLibrary() throws ParseException {
        Token lib, child = null;
        List children = null;
        lib = jj_consume_token(START_LIBRARY);
        label_20:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case START_DEFINITION:
                    ;
                    break;
                default:
                    jj_la1[56] = jj_gen;
                    break label_20;
            }
            child = parseDefinition();
            children = addChild(children, child);
        }
        jj_consume_token(END_LIBRARY);
        if (visitor != null) {
            visitor.parseLibrary(lib, children);
        }
        {
            if (true) return lib;
        }
        throw new Error("Missing return statement in function");
    }

    /**
     * <Definition> tag for a Library
     * Has one attribute 'name' as an identifier.
     * At most one child may be specified.
     */
    final public Token parseDefinition() throws ParseException {
        Token definition, child = null;
        definition = jj_consume_token(START_DEFINITION);
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case START_DESIGNLAYER:
            case START_ELEMENT:
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case START_DESIGNLAYER:
                        child = parseDesignLayer();
                        break;
                    case START_ELEMENT:
                        child = parseApplicationComponent();
                        break;
                    default:
                        jj_la1[57] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
                break;
            default:
                jj_la1[58] = jj_gen;
                ;
        }
        jj_consume_token(END_DEFINITION);
        if (visitor != null) {
            visitor.parseDefinition(definition, child);
        }
        {
            if (true) return definition;
        }
        throw new Error("Missing return statement in function");
    }

    /**
     * User defined Token Manager.
     */
    public TokenManager token_source;
    /**
     * Current token.
     */
    public Token token;
    /**
     * Next token.
     */
    public Token jj_nt;
    private int jj_ntk;
    private int jj_gen;
    final private int[] jj_la1 = new int[59];
    static private int[] jj_la1_0;
    static private int[] jj_la1_1;
    static private int[] jj_la1_2;

    static {
        jj_la1_init_0();
        jj_la1_init_1();
        jj_la1_init_2();
    }

    private static void jj_la1_init_0() {
        jj_la1_0 = new int[]{0xaaaaaaaa, 0xaaaaaaaa, 0xaaaaaaa2, 0xaaaaaaa2, 0xaaaaaaa2, 0xaaaaaaa2, 0x2a0, 0xaaaaa802, 0xaaaaa802, 0x0, 0x0, 0x0, 0x0, 0xaaaaa800, 0xaaaaa802, 0xaaaaa802, 0xaa280000, 0xaa280000, 0x0, 0x0, 0x0, 0x0, 0x0, 0xaa280802, 0xaa280802, 0xaa280802, 0xaa280802, 0x0, 0x0, 0xaa000000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xaa080000, 0xaa080000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x2, 0x0, 0x0, 0x0, 0x2, 0x2,};
    }

    private static void jj_la1_init_1() {
        jj_la1_1 = new int[]{0x8aa820aa, 0x8aa820aa, 0x80a0002a, 0x80a0002a, 0x80a0002a, 0x80a0002a, 0x0, 0x80a820aa, 0x80a820aa, 0x82080, 0x0, 0x0, 0x0, 0xa0002a, 0x80a0002a, 0x80a0002a, 0x8000002a, 0x8000002a, 0x0, 0x80000000, 0x0, 0x80000000, 0x0, 0x8080002a, 0x8080002a, 0x8080002a, 0x8080002a, 0x80000000, 0x80000000, 0x2a, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x80000200, 0x80000200, 0x80000800, 0x80000800, 0x8000002a, 0x8000002a, 0x0, 0x80008000, 0x80008000, 0x80020000, 0x80020000, 0x80000000, 0x0, 0x80020000, 0x80020000, 0x80000000, 0x80000000, 0x0, 0x0, 0x20000000, 0x80000000, 0x80000000,};
    }

    private static void jj_la1_init_2() {
        jj_la1_2 = new int[]{0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x1, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x1, 0x0, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x0, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0, 0x0, 0x5, 0x5, 0x0, 0x0, 0x0,};
    }


    /**
     * Constructor with user supplied Token Manager.
     */
    public Parser(TokenManager tm) {
        token_source = tm;
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 59; i++) jj_la1[i] = -1;
    }

    /**
     * Reinitialise.
     */
    public void ReInit(TokenManager tm) {
        token_source = tm;
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 59; i++) jj_la1[i] = -1;
    }

    private Token jj_consume_token(int kind) throws ParseException {
        Token oldToken;
        if ((oldToken = token).next != null) token = token.next;
        else token = token.next = token_source.getNextToken();
        jj_ntk = -1;
        if (token.kind == kind) {
            jj_gen++;
            return token;
        }
        token = oldToken;
        jj_kind = kind;
        throw generateParseException();
    }


    /**
     * Get the next Token.
     */
    final public Token getNextToken() {
        if (token.next != null) token = token.next;
        else token = token.next = token_source.getNextToken();
        jj_ntk = -1;
        jj_gen++;
        return token;
    }

    /**
     * Get the specific Token.
     */
    final public Token getToken(int index) {
        Token t = token;
        for (int i = 0; i < index; i++) {
            if (t.next != null) t = t.next;
            else t = t.next = token_source.getNextToken();
        }
        return t;
    }

    private int jj_ntk() {
        if ((jj_nt = token.next) == null)
            return (jj_ntk = (token.next = token_source.getNextToken()).kind);
        else
            return (jj_ntk = jj_nt.kind);
    }

    private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
    private int[] jj_expentry;
    private int jj_kind = -1;

    /**
     * Generate ParseException.
     */
    public ParseException generateParseException() {
        jj_expentries.clear();
        boolean[] la1tokens = new boolean[67];
        if (jj_kind >= 0) {
            la1tokens[jj_kind] = true;
            jj_kind = -1;
        }
        for (int i = 0; i < 59; i++) {
            if (jj_la1[i] == jj_gen) {
                for (int j = 0; j < 32; j++) {
                    if ((jj_la1_0[i] & (1 << j)) != 0) {
                        la1tokens[j] = true;
                    }
                    if ((jj_la1_1[i] & (1 << j)) != 0) {
                        la1tokens[32 + j] = true;
                    }
                    if ((jj_la1_2[i] & (1 << j)) != 0) {
                        la1tokens[64 + j] = true;
                    }
                }
            }
        }
        for (int i = 0; i < 67; i++) {
            if (la1tokens[i]) {
                jj_expentry = new int[1];
                jj_expentry[0] = i;
                jj_expentries.add(jj_expentry);
            }
        }
        int[][] exptokseq = new int[jj_expentries.size()][];
        for (int i = 0; i < jj_expentries.size(); i++) {
            exptokseq[i] = jj_expentries.get(i);
        }
        return new ParseException(token, exptokseq, tokenImage);
    }

    /**
     * Enable tracing.
     */
    final public void enable_tracing() {
    }

    /**
     * Disable tracing.
     */
    final public void disable_tracing() {
    }

}
