/* Generated By:JavaCC: Do not edit this line. Parser.java */
package flex2.compiler.mxml;

import java.lang.reflect.*;
import java.util.*;

/**
 * MXML parser: JavaCC + SAXParser as the tokenizer...
 *
 * @author Clement Wong
 */
public class Parser implements MXMLNamespaces, ParserConstants {
    private static final HashSet SPECIAL_COMPONENT_TAGS = new HashSet(8);
    static
    {
        SPECIAL_COMPONENT_TAGS.add("State");
        SPECIAL_COMPONENT_TAGS.add("HTTPService");
        SPECIAL_COMPONENT_TAGS.add("RemoteObject");
        SPECIAL_COMPONENT_TAGS.add("WebService");
        SPECIAL_COMPONENT_TAGS.add("method");
        SPECIAL_COMPONENT_TAGS.add("arguments");
        SPECIAL_COMPONENT_TAGS.add("operation");
        SPECIAL_COMPONENT_TAGS.add("request");
    }

    private static final HashSet FXG_LANGUAGE_TAGS = new HashSet(3);
    static
    {
        FXG_LANGUAGE_TAGS.add("Definition");
        FXG_LANGUAGE_TAGS.add("Library");
        FXG_LANGUAGE_TAGS.add("Private");
    }

    private static final HashSet MXML2009_NEW_TAGS = new HashSet(6);
    static
    {
        MXML2009_NEW_TAGS.add("Declarations");
        MXML2009_NEW_TAGS.add("Definition");
        MXML2009_NEW_TAGS.add("DesignLayer");
        MXML2009_NEW_TAGS.add("Library");
        MXML2009_NEW_TAGS.add("Private");
        MXML2009_NEW_TAGS.add("Reparent");
    }

    private static final Map ConstantMappings = new HashMap();

    static
    {
        // FIXME: HACK for the Apache Port.  The version of javacc.jar that was being used is ancient and is no longer available.
        // Some time over the years the format of some of the tokenImage strings in the generated file ParserConstants changed 
        // from, for example, "Script" to "\"Script\"" and "/Script" to "\"/Script\"".  If there are quotes, strip them off so 
        // that the rest of this code continues to work with no additional changes needed.
        for (int j = 0, length = ParserConstants.tokenImage.length; j < length; j++)
        {
            String image = ParserConstants.tokenImage[j];
            if (image.length() >= 2 && image.charAt(0) == '\u005c"' && image.charAt(image.length() - 1) == '\u005c"')
                    ParserConstants.tokenImage[j] = image.substring(1, image.length() - 1);
        }

        // C: This static initializer fixes the token ids to match the index of
        //    their corresponding token strings in tokenImage.
        Field[] fields = ParserConstants.class.getFields();
        for (int i = 0, count = fields.length; i < count; i++)
        {
            try
            {
                String name = fields[i].getName();

                if (!"tokenImage".equals(name))
                {
                    int value = fields[i].getInt(ParserConstants.class);
                    for (int j = 0, length = ParserConstants.tokenImage.length; j < length; j++)
                    {
                        String image = ParserConstants.tokenImage[j];
                        switch (image.charAt(0))
                        {
                        case '<':
                            image = image.substring(1, image.length() - 1);
                            break;
                        case '/':
                            image = "END_" + image.substring(1).toUpperCase();
                            break;
                        default:
                            image = "START_" + image.toUpperCase();
                        }

                        if ("START_ELEMENT".equals(image) || "END_ELEMENT".equals(image))
                        {
                            ParserConstants.tokenImage[j] = "Non-MXML language element";
                        }

                        if (image.equals(name))
                        {
                            String temp = ParserConstants.tokenImage[value];
                            ParserConstants.tokenImage[value] = ParserConstants.tokenImage[j];
                            ParserConstants.tokenImage[j] = temp;
                            ConstantMappings.put(ParserConstants.tokenImage[value], new Integer(value));
                            break;
                        }
                    }
                }
            }
            catch (IllegalAccessException ex)
            {
                ex.printStackTrace();
            }
        }
    }

    public static final int findElementType(String uri, String localName, boolean isStart)
    {
        if (MXML_2009_NAMESPACE.equals(uri) &&
            !SPECIAL_COMPONENT_TAGS.contains(localName))
        {
            String localPart = (isStart) ? localName : "/" + localName;
            if (ConstantMappings.containsKey(localPart))
            {
                return ((Integer) ConstantMappings.get(localPart)).intValue();
            }
        }
        else if (MXML_2006_NAMESPACE.equals(uri) &&
             !MXML2009_NEW_TAGS.contains(localName))
        {
            String localPart = (isStart) ? localName : "/" + localName;
            if (ConstantMappings.containsKey(localPart))
            {
                return ((Integer) ConstantMappings.get(localPart)).intValue();
            }
        }
        else if (FXG_2008_NAMESPACE.equals(uri) &&
              FXG_LANGUAGE_TAGS.contains(localName))
        {
            String localPart = (isStart) ? localName : "/" + localName;
            if (ConstantMappings.containsKey(localPart))
            {
                return ((Integer) ConstantMappings.get(localPart)).intValue();
            }
        }
        else if ((SPARK_NAMESPACE.equals(uri) || MX_NAMESPACE.equals(uri)) &&
             SPECIAL_COMPONENT_TAGS.contains(localName))
        {
            String localPart = (isStart) ? localName : "/" + localName;
            if (ConstantMappings.containsKey(localPart))
            {
                return ((Integer) ConstantMappings.get(localPart)).intValue();
            }
        }

        return (isStart) ? ParserConstants.START_ELEMENT : ParserConstants.END_ELEMENT;
    }

    /**
     * Set a visitor implementation, e.g. SyntaxAnalyzer
     */
    public void setVisitor(MxmlVisitor v)
    {
        visitor = v;
    }

    private MxmlVisitor visitor;

    // Helper function: Lazy instantiation of List.
    private static final List addChild(List children, Token child)
    {
        if (children == null)
        {
            children = new ArrayList();
        }
        children.add(child);

        return children;
    }

    // Helper function: Lazy instantiation of Map.
    private static final Map addAttribute(Map attributes, Token name, Token value)
    {
        if (attributes == null)
        {
            attributes = new HashMap();
        }
        attributes.put(name, value);

        return attributes;
    }

  final public Token parseApplication() throws ParseException {
    Token t;
    t = parseApplicationComponent();
    jj_consume_token(0);
        {if (true) return t;}
    throw new Error("Missing return statement in function");
  }

  final public Token parseApplicationComponent() throws ParseException {
    Token app, child;
    List children = null;
    app = jj_consume_token(START_ELEMENT);
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case START_DESIGNLAYER:
      case START_DECLARATIONS:
      case START_STYLE:
      case START_SCRIPT:
      case START_METADATA:
      case START_STATE:
      case START_MODEL:
      case START_XML:
      case START_XMLLIST:
      case START_ARRAY:
      case START_VECTOR:
      case START_BINDING:
      case START_STRING:
      case START_NUMBER:
      case START_INT:
      case START_UINT:
      case START_BOOLEAN:
      case START_CLASS:
      case START_FUNCTION:
      case START_REMOTEOBJECT:
      case START_WEBSERVICE:
      case START_HTTPSERVICE:
      case START_COMPONENT:
      case START_REPARENT:
      case START_PRIVATE:
      case START_LIBRARY:
      case START_ELEMENT:
      case CDATA:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CDATA:
        child = jj_consume_token(CDATA);
        break;
      case START_DESIGNLAYER:
        child = parseDesignLayer();
        break;
      case START_STYLE:
      case START_SCRIPT:
      case START_METADATA:
        child = parseLanguageComponent();
        break;
      case START_DECLARATIONS:
        child = parseDeclarations();
        break;
      case START_LIBRARY:
        child = parseLibrary();
        break;
      case START_REMOTEOBJECT:
      case START_WEBSERVICE:
      case START_HTTPSERVICE:
        child = parseServiceComponent();
        break;
      case START_STATE:
      case START_MODEL:
      case START_XML:
      case START_XMLLIST:
      case START_ARRAY:
      case START_VECTOR:
      case START_BINDING:
      case START_STRING:
      case START_NUMBER:
      case START_INT:
      case START_UINT:
      case START_BOOLEAN:
      case START_CLASS:
      case START_FUNCTION:
      case START_COMPONENT:
      case START_REPARENT:
        child = parseFacelessComponent();
        break;
      case START_ELEMENT:
        child = parseUIComponent();
        break;
      case START_PRIVATE:
        child = parsePrivate();
        break;
      default:
        jj_la1[1] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
            children = addChild(children, child);
    }
    jj_consume_token(END_ELEMENT);
        if (visitor != null) { visitor.parseApplication(app, children); }
        {if (true) return app;}
    throw new Error("Missing return statement in function");
  }

  final public Token parseUIComponent() throws ParseException {
    Token comp, child;
    List children = null;
    comp = jj_consume_token(START_ELEMENT);
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case START_DESIGNLAYER:
      case START_STYLE:
      case START_SCRIPT:
      case START_METADATA:
      case START_STATE:
      case START_MODEL:
      case START_XML:
      case START_XMLLIST:
      case START_ARRAY:
      case START_VECTOR:
      case START_BINDING:
      case START_STRING:
      case START_NUMBER:
      case START_INT:
      case START_UINT:
      case START_BOOLEAN:
      case START_CLASS:
      case START_FUNCTION:
      case START_COMPONENT:
      case START_REPARENT:
      case START_ELEMENT:
      case CDATA:
        ;
        break;
      default:
        jj_la1[2] = jj_gen;
        break label_2;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CDATA:
        child = jj_consume_token(CDATA);
        break;
      case START_DESIGNLAYER:
        child = parseDesignLayer();
        break;
      case START_STYLE:
      case START_SCRIPT:
      case START_METADATA:
        child = parseLanguageComponent();
        break;
      case START_STATE:
      case START_MODEL:
      case START_XML:
      case START_XMLLIST:
      case START_ARRAY:
      case START_VECTOR:
      case START_BINDING:
      case START_STRING:
      case START_NUMBER:
      case START_INT:
      case START_UINT:
      case START_BOOLEAN:
      case START_CLASS:
      case START_FUNCTION:
      case START_COMPONENT:
      case START_REPARENT:
        child = parseFacelessComponent();
        break;
      case START_ELEMENT:
        child = parseUIComponent();
        break;
      default:
        jj_la1[3] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                children = addChild(children, child);
    }
    jj_consume_token(END_ELEMENT);
        if (visitor != null) { visitor.parseComponent(comp, children); }
        {if (true) return comp;}
    throw new Error("Missing return statement in function");
  }

  final public Token parseDesignLayer() throws ParseException {
    Token t, child;
    List children = null;
    t = jj_consume_token(START_DESIGNLAYER);
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case START_DESIGNLAYER:
      case START_STYLE:
      case START_SCRIPT:
      case START_METADATA:
      case START_STATE:
      case START_MODEL:
      case START_XML:
      case START_XMLLIST:
      case START_ARRAY:
      case START_VECTOR:
      case START_BINDING:
      case START_STRING:
      case START_NUMBER:
      case START_INT:
      case START_UINT:
      case START_BOOLEAN:
      case START_CLASS:
      case START_FUNCTION:
      case START_COMPONENT:
      case START_REPARENT:
      case START_ELEMENT:
      case CDATA:
        ;
        break;
      default:
        jj_la1[4] = jj_gen;
        break label_3;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CDATA:
        child = jj_consume_token(CDATA);
        break;
      case START_DESIGNLAYER:
        child = parseDesignLayer();
        break;
      case START_STYLE:
      case START_SCRIPT:
      case START_METADATA:
        child = parseLanguageComponent();
        break;
      case START_STATE:
      case START_MODEL:
      case START_XML:
      case START_XMLLIST:
      case START_ARRAY:
      case START_VECTOR:
      case START_BINDING:
      case START_STRING:
      case START_NUMBER:
      case START_INT:
      case START_UINT:
      case START_BOOLEAN:
      case START_CLASS:
      case START_FUNCTION:
      case START_COMPONENT:
      case START_REPARENT:
        child = parseFacelessComponent();
        break;
      case START_ELEMENT:
        child = parseUIComponent();
        break;
      default:
        jj_la1[5] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
            children = addChild(children, child);
    }
    jj_consume_token(END_DESIGNLAYER);
        if (visitor != null) { visitor.parseDesignLayer(t, children); }
        {if (true) return t;}
    throw new Error("Missing return statement in function");
  }

  final public Token parseLanguageComponent() throws ParseException {
    Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case START_METADATA:
      t = parseMetaData();
      break;
    case START_SCRIPT:
      t = parseScript();
      break;
    case START_STYLE:
      t = parseStyle();
      break;
    default:
      jj_la1[6] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        {if (true) return t;}
    throw new Error("Missing return statement in function");
  }

  final public Token parseDeclarations() throws ParseException {
    Token t, child;
    List children = null;
    t = jj_consume_token(START_DECLARATIONS);
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case START_DESIGNLAYER:
      case START_STATE:
      case START_MODEL:
      case START_XML:
      case START_XMLLIST:
      case START_ARRAY:
      case START_VECTOR:
      case START_BINDING:
      case START_STRING:
      case START_NUMBER:
      case START_INT:
      case START_UINT:
      case START_BOOLEAN:
      case START_CLASS:
      case START_FUNCTION:
      case START_REMOTEOBJECT:
      case START_WEBSERVICE:
      case START_HTTPSERVICE:
      case START_COMPONENT:
      case START_REPARENT:
      case START_ELEMENT:
        ;
        break;
      default:
        jj_la1[7] = jj_gen;
        break label_4;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case START_REMOTEOBJECT:
      case START_WEBSERVICE:
      case START_HTTPSERVICE:
        child = parseServiceComponent();
        break;
      case START_STATE:
      case START_MODEL:
      case START_XML:
      case START_XMLLIST:
      case START_ARRAY:
      case START_VECTOR:
      case START_BINDING:
      case START_STRING:
      case START_NUMBER:
      case START_INT:
      case START_UINT:
      case START_BOOLEAN:
      case START_CLASS:
      case START_FUNCTION:
      case START_COMPONENT:
      case START_REPARENT:
        child = parseFacelessComponent();
        break;
      case START_ELEMENT:
        child = parseUIComponent();
        break;
      case START_DESIGNLAYER:
        child = parseDesignLayer();
        break;
      default:
        jj_la1[8] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                children = addChild(children, child);
    }
    jj_consume_token(END_DECLARATIONS);
        if (visitor != null) { visitor.parseDeclarations(t, children); }
        {if (true) return t;}
    throw new Error("Missing return statement in function");
  }

  final public Token parseServiceComponent() throws ParseException {
    Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case START_WEBSERVICE:
      t = parseWebService();
      break;
    case START_HTTPSERVICE:
      t = parseHTTPService();
      break;
    case START_REMOTEOBJECT:
      t = parseRemoteObject();
      break;
    default:
      jj_la1[9] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        {if (true) return t;}
    throw new Error("Missing return statement in function");
  }

  final public Token parseStyle() throws ParseException {
    Token t, d = null;
    t = jj_consume_token(START_STYLE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CDATA:
      d = jj_consume_token(CDATA);
      break;
    default:
      jj_la1[10] = jj_gen;
      ;
    }
    jj_consume_token(END_STYLE);
        if (visitor != null) { visitor.parseStyle(t, d); }
        {if (true) return t;}
    throw new Error("Missing return statement in function");
  }

  final public Token parseScript() throws ParseException {
    Token t, d = null;
    t = jj_consume_token(START_SCRIPT);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CDATA:
      d = jj_consume_token(CDATA);
      break;
    default:
      jj_la1[11] = jj_gen;
      ;
    }
    jj_consume_token(END_SCRIPT);
        if (visitor != null) { visitor.parseScript(t, d); }
        {if (true) return t;}
    throw new Error("Missing return statement in function");
  }

  final public Token parseMetaData() throws ParseException {
    Token t, d = null;
    t = jj_consume_token(START_METADATA);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CDATA:
      d = jj_consume_token(CDATA);
      break;
    default:
      jj_la1[12] = jj_gen;
      ;
    }
    jj_consume_token(END_METADATA);
        if (visitor != null) { visitor.parseMetaData(t, d); }
        {if (true) return t;}
    throw new Error("Missing return statement in function");
  }

  final public Token parseFacelessComponent() throws ParseException {
    Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case START_MODEL:
      t = parseModel();
      break;
    case START_XML:
      t = parseXML();
      break;
    case START_XMLLIST:
      t = parseXMLList();
      break;
    case START_ARRAY:
      t = parseArray();
      break;
    case START_VECTOR:
      t = parseVector();
      break;
    case START_BINDING:
      t = parseBinding();
      break;
    case START_STRING:
    case START_NUMBER:
    case START_INT:
    case START_UINT:
    case START_BOOLEAN:
    case START_CLASS:
    case START_FUNCTION:
      t = parsePrimitive();
      break;
    case START_COMPONENT:
      t = parseInlineComponent();
      break;
    case START_STATE:
      t = parseState();
      break;
    case START_REPARENT:
      t = parseReparent();
      break;
    default:
      jj_la1[13] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        {if (true) return t;}
    throw new Error("Missing return statement in function");
  }

  final public Token parseState() throws ParseException {
    Token t, child;
    List children = null;
    t = jj_consume_token(START_STATE);
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case START_DESIGNLAYER:
      case START_STATE:
      case START_MODEL:
      case START_XML:
      case START_XMLLIST:
      case START_ARRAY:
      case START_VECTOR:
      case START_BINDING:
      case START_STRING:
      case START_NUMBER:
      case START_INT:
      case START_UINT:
      case START_BOOLEAN:
      case START_CLASS:
      case START_FUNCTION:
      case START_COMPONENT:
      case START_REPARENT:
      case START_ELEMENT:
        ;
        break;
      default:
        jj_la1[14] = jj_gen;
        break label_5;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case START_DESIGNLAYER:
        child = parseDesignLayer();
        break;
      case START_STATE:
      case START_MODEL:
      case START_XML:
      case START_XMLLIST:
      case START_ARRAY:
      case START_VECTOR:
      case START_BINDING:
      case START_STRING:
      case START_NUMBER:
      case START_INT:
      case START_UINT:
      case START_BOOLEAN:
      case START_CLASS:
      case START_FUNCTION:
      case START_COMPONENT:
      case START_REPARENT:
        child = parseFacelessComponent();
        break;
      case START_ELEMENT:
        child = parseUIComponent();
        break;
      default:
        jj_la1[15] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                children = addChild(children, child);
    }
    jj_consume_token(END_STATE);
        if (visitor != null) { visitor.parseState(t, children); }
        {if (true) return t;}
    throw new Error("Missing return statement in function");
  }

  final public Token parseModel() throws ParseException {
    Token t, obj = null;
    List children = null;
    t = jj_consume_token(START_MODEL);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CDATA:
      obj = jj_consume_token(CDATA);
                        children = addChild(children, obj);
      break;
    default:
      jj_la1[18] = jj_gen;
      label_6:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case START_ARRAY:
        case START_VECTOR:
        case START_STRING:
        case START_NUMBER:
        case START_INT:
        case START_UINT:
        case START_BOOLEAN:
        case START_CLASS:
        case START_FUNCTION:
        case START_ELEMENT:
          ;
          break;
        default:
          jj_la1[16] = jj_gen;
          break label_6;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case START_STRING:
        case START_NUMBER:
        case START_INT:
        case START_UINT:
        case START_BOOLEAN:
        case START_CLASS:
        case START_FUNCTION:
          obj = parsePrimitive();
          break;
        case START_ARRAY:
          obj = parseArray();
          break;
        case START_VECTOR:
          obj = parseVector();
          break;
        case START_ELEMENT:
          obj = parseAnonymousObject();
          break;
        default:
          jj_la1[17] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
                children = addChild(children, obj);
      }
    }
    jj_consume_token(END_MODEL);
        if (visitor != null) { visitor.parseModel(t, children); }
        {if (true) return t;}
    throw new Error("Missing return statement in function");
  }

  final public Token parseXML() throws ParseException {
    Token t, obj = null;
    List children = null;
    t = jj_consume_token(START_XML);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CDATA:
      obj = jj_consume_token(CDATA);
                        children = addChild(children, obj);
      break;
    default:
      jj_la1[20] = jj_gen;
      label_7:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case START_ELEMENT:
          ;
          break;
        default:
          jj_la1[19] = jj_gen;
          break label_7;
        }
        obj = parseAnonymousObject();
              children = addChild(children, obj);
      }
    }
    jj_consume_token(END_XML);
        if (visitor != null) { visitor.parseXML(t, children); }
        {if (true) return t;}
    throw new Error("Missing return statement in function");
  }

  final public Token parseXMLList() throws ParseException {
    Token t, obj = null;
    List children = null;
    t = jj_consume_token(START_XMLLIST);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CDATA:
      obj = jj_consume_token(CDATA);
                        children = addChild(children, obj);
      break;
    default:
      jj_la1[22] = jj_gen;
      label_8:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case START_ELEMENT:
          ;
          break;
        default:
          jj_la1[21] = jj_gen;
          break label_8;
        }
        obj = parseAnonymousObject();
              children = addChild(children, obj);
      }
    }
    jj_consume_token(END_XMLLIST);
        if (visitor != null) { visitor.parseXMLList(t, children); }
        {if (true) return t;}
    throw new Error("Missing return statement in function");
  }

  final public Token parseArray() throws ParseException {
    Token t, obj = null;
    List children = null;
    t = jj_consume_token(START_ARRAY);
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case START_DESIGNLAYER:
      case START_STATE:
      case START_ARRAY:
      case START_VECTOR:
      case START_STRING:
      case START_NUMBER:
      case START_INT:
      case START_UINT:
      case START_BOOLEAN:
      case START_CLASS:
      case START_FUNCTION:
      case START_REPARENT:
      case START_ELEMENT:
      case CDATA:
        ;
        break;
      default:
        jj_la1[23] = jj_gen;
        break label_9;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CDATA:
        obj = jj_consume_token(CDATA);
        break;
      case START_DESIGNLAYER:
        obj = parseDesignLayer();
        break;
      case START_STRING:
      case START_NUMBER:
      case START_INT:
      case START_UINT:
      case START_BOOLEAN:
      case START_CLASS:
      case START_FUNCTION:
        obj = parsePrimitive();
        break;
      case START_ARRAY:
        obj = parseArray();
        break;
      case START_VECTOR:
        obj = parseVector();
        break;
      case START_ELEMENT:
        obj = parseUIComponent();
        break;
      case START_REPARENT:
        obj = parseReparent();
        break;
      case START_STATE:
        obj = parseState();
        break;
      default:
        jj_la1[24] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                children = addChild(children, obj);
    }
    jj_consume_token(END_ARRAY);
        if (visitor != null) { visitor.parseArray(t, children); }
        {if (true) return t;}
    throw new Error("Missing return statement in function");
  }

  final public Token parseVector() throws ParseException {
    Token t, obj = null;
    List children = null;
    t = jj_consume_token(START_VECTOR);
    label_10:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case START_DESIGNLAYER:
      case START_STATE:
      case START_ARRAY:
      case START_VECTOR:
      case START_STRING:
      case START_NUMBER:
      case START_INT:
      case START_UINT:
      case START_BOOLEAN:
      case START_CLASS:
      case START_FUNCTION:
      case START_REPARENT:
      case START_ELEMENT:
      case CDATA:
        ;
        break;
      default:
        jj_la1[25] = jj_gen;
        break label_10;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CDATA:
        obj = jj_consume_token(CDATA);
        break;
      case START_DESIGNLAYER:
        obj = parseDesignLayer();
        break;
      case START_STRING:
      case START_NUMBER:
      case START_INT:
      case START_UINT:
      case START_BOOLEAN:
      case START_CLASS:
      case START_FUNCTION:
        obj = parsePrimitive();
        break;
      case START_ARRAY:
        obj = parseArray();
        break;
      case START_VECTOR:
        obj = parseVector();
        break;
      case START_ELEMENT:
        obj = parseUIComponent();
        break;
      case START_REPARENT:
        obj = parseReparent();
        break;
      case START_STATE:
        obj = parseState();
        break;
      default:
        jj_la1[26] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                children = addChild(children, obj);
    }
    jj_consume_token(END_VECTOR);
        if (visitor != null) { visitor.parseVector(t, children); }
        {if (true) return t;}
    throw new Error("Missing return statement in function");
  }

  final public Token parseBinding() throws ParseException {
    Token t;
    t = jj_consume_token(START_BINDING);
    jj_consume_token(END_BINDING);
        if (visitor != null) { visitor.parseBinding(t); }
        {if (true) return t;}
    throw new Error("Missing return statement in function");
  }

  final public Token parseAnonymousObject() throws ParseException {
    Token t, obj = null;
    List children = null;
    t = jj_consume_token(START_ELEMENT);
    label_11:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case START_ELEMENT:
      case CDATA:
        ;
        break;
      default:
        jj_la1[27] = jj_gen;
        break label_11;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CDATA:
        obj = jj_consume_token(CDATA);
        break;
      case START_ELEMENT:
        obj = parseAnonymousObject();
        break;
      default:
        jj_la1[28] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                children = addChild(children, obj);
    }
    jj_consume_token(END_ELEMENT);
        if (visitor != null) { visitor.parseAnonymousObject(t, children); }
        {if (true) return t;}
    throw new Error("Missing return statement in function");
  }

  final public Token parsePrimitive() throws ParseException {
    Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case START_STRING:
      t = parseString();
      break;
    case START_NUMBER:
      t = parseNumber();
      break;
    case START_INT:
      t = parseInt();
      break;
    case START_UINT:
      t = parseUInt();
      break;
    case START_BOOLEAN:
      t = parseBoolean();
      break;
    case START_CLASS:
      t = parseClass();
      break;
    case START_FUNCTION:
      t = parseFunction();
      break;
    default:
      jj_la1[29] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        {if (true) return t;}
    throw new Error("Missing return statement in function");
  }

  final public Token parseString() throws ParseException {
    Token t, data = null;
    t = jj_consume_token(START_STRING);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CDATA:
      data = jj_consume_token(CDATA);
      break;
    default:
      jj_la1[30] = jj_gen;
      ;
    }
    jj_consume_token(END_STRING);
        if (visitor != null) { visitor.parseString(t, data); }
        {if (true) return t;}
    throw new Error("Missing return statement in function");
  }

  final public Token parseNumber() throws ParseException {
    Token t, data = null;
    t = jj_consume_token(START_NUMBER);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CDATA:
      data = jj_consume_token(CDATA);
      break;
    default:
      jj_la1[31] = jj_gen;
      ;
    }
    jj_consume_token(END_NUMBER);
        if (visitor != null) { visitor.parseNumber(t, data); }
        {if (true) return t;}
    throw new Error("Missing return statement in function");
  }

  final public Token parseInt() throws ParseException {
    Token t, data = null;
    t = jj_consume_token(START_INT);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CDATA:
      data = jj_consume_token(CDATA);
      break;
    default:
      jj_la1[32] = jj_gen;
      ;
    }
    jj_consume_token(END_INT);
        if (visitor != null) { visitor.parseInt(t, data); }
        {if (true) return t;}
    throw new Error("Missing return statement in function");
  }

  final public Token parseUInt() throws ParseException {
    Token t, data = null;
    t = jj_consume_token(START_UINT);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CDATA:
      data = jj_consume_token(CDATA);
      break;
    default:
      jj_la1[33] = jj_gen;
      ;
    }
    jj_consume_token(END_UINT);
        if (visitor != null) { visitor.parseUInt(t, data); }
        {if (true) return t;}
    throw new Error("Missing return statement in function");
  }

  final public Token parseBoolean() throws ParseException {
    Token t, data = null;
    t = jj_consume_token(START_BOOLEAN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CDATA:
      data = jj_consume_token(CDATA);
      break;
    default:
      jj_la1[34] = jj_gen;
      ;
    }
    jj_consume_token(END_BOOLEAN);
        if (visitor != null) { visitor.parseBoolean(t, data); }
        {if (true) return t;}
    throw new Error("Missing return statement in function");
  }

  final public Token parseClass() throws ParseException {
    Token t, data = null;
    t = jj_consume_token(START_CLASS);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CDATA:
      data = jj_consume_token(CDATA);
      break;
    default:
      jj_la1[35] = jj_gen;
      ;
    }
    jj_consume_token(END_CLASS);
        if (visitor != null) { visitor.parseClass(t, data); }
        {if (true) return t;}
    throw new Error("Missing return statement in function");
  }

  final public Token parseFunction() throws ParseException {
    Token t, data = null;
    t = jj_consume_token(START_FUNCTION);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CDATA:
      data = jj_consume_token(CDATA);
      break;
    default:
      jj_la1[36] = jj_gen;
      ;
    }
    jj_consume_token(END_FUNCTION);
        if (visitor != null) { visitor.parseFunction(t, data); }
        {if (true) return t;}
    throw new Error("Missing return statement in function");
  }

/**
 *
 * SERVICE TAGS
 *
 */

/***
 * <mx:RemoteObject/>
 * Special child tag type <mx:method/>.
 */
  final public Token parseRemoteObject() throws ParseException {
    Token t, child;
    List children = null;
    t = jj_consume_token(START_REMOTEOBJECT);
    label_12:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case START_METHOD:
      case START_ELEMENT:
        ;
        break;
      default:
        jj_la1[37] = jj_gen;
        break label_12;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case START_METHOD:
        child = parseMethod();
        break;
      case START_ELEMENT:
        child = parseUIComponent();
        break;
      default:
        jj_la1[38] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
            children = addChild(children, child);
    }
    jj_consume_token(END_REMOTEOBJECT);
        if (visitor != null) { visitor.parseRemoteObject(t, children); }
        {if (true) return t;}
    throw new Error("Missing return statement in function");
  }

/**
 * <mx:RemoteObject>/<mx:method/>.
 * Special child tag type <mx:arguments/>.
 */
  final public Token parseMethod() throws ParseException {
    Token t, child;
    List children = null;
    t = jj_consume_token(START_METHOD);
    label_13:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case START_ARGUMENTS:
      case START_ELEMENT:
        ;
        break;
      default:
        jj_la1[39] = jj_gen;
        break label_13;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case START_ARGUMENTS:
        child = parseArguments();
        break;
      case START_ELEMENT:
        child = parseUIComponent();
        break;
      default:
        jj_la1[40] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
            children = addChild(children, child);
    }
    jj_consume_token(END_METHOD);
        if (visitor != null) { visitor.parseMethod(t, children); }
        {if (true) return t;}
    throw new Error("Missing return statement in function");
  }

/**
 * <mx:RemoteObject>/<mx:method>/<mx:arguments/>
 * Parsed as an anonymous object.
 * TODO: add metadata-driven ability to parse any property-initializing child tag as a key/value map.
 * BUT NOTE that in this particular use case, we *also* save argument order (see RemoteObjectBuilder).
 * So to be completely free of special processing, we'd need to add that as a metadata-triggered option as well.
 */
  final public Token parseArguments() throws ParseException {
    Token t, child = null;
    List children = null;
    t = jj_consume_token(START_ARGUMENTS);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CDATA:
      child = jj_consume_token(CDATA);
                          children = addChild(children, child);
      break;
    default:
      jj_la1[43] = jj_gen;
      label_14:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case START_ARRAY:
        case START_STRING:
        case START_NUMBER:
        case START_INT:
        case START_UINT:
        case START_BOOLEAN:
        case START_CLASS:
        case START_FUNCTION:
        case START_ELEMENT:
          ;
          break;
        default:
          jj_la1[41] = jj_gen;
          break label_14;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case START_STRING:
        case START_NUMBER:
        case START_INT:
        case START_UINT:
        case START_BOOLEAN:
        case START_CLASS:
        case START_FUNCTION:
          // LOOKAHEAD ( { "true".equals(((Element) token).getAttribute("literal")) } )
                          //    child = parseXML() |
                          child = parsePrimitive();
          break;
        case START_ARRAY:
          child = parseArray();
          break;
        case START_ELEMENT:
          child = parseAnonymousObject();
          break;
        default:
          jj_la1[42] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
                children = addChild(children, child);
      }
    }
    jj_consume_token(END_ARGUMENTS);
        if (visitor != null) { visitor.parseArguments(t, children); }
        {if (true) return t;}
    throw new Error("Missing return statement in function");
  }

/***
 * <mx:WebService/>
 * Special child tag type <mx:operation/>.
 */
  final public Token parseWebService() throws ParseException {
    Token t, child;
    List children = null;
    t = jj_consume_token(START_WEBSERVICE);
    label_15:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case START_OPERATION:
      case START_ELEMENT:
        ;
        break;
      default:
        jj_la1[44] = jj_gen;
        break label_15;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case START_OPERATION:
        child = parseOperation();
        break;
      case START_ELEMENT:
        child = parseUIComponent();
        break;
      default:
        jj_la1[45] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
            children = addChild(children, child);
    }
    jj_consume_token(END_WEBSERVICE);
        if (visitor != null) { visitor.parseWebService(t, children); }
        {if (true) return t;}
    throw new Error("Missing return statement in function");
  }

/**
 * <mx:WebService>/<mx:operation/>.
 * Special child tag type <mx:request/>.
 * Note: at most one <mx:request/> child may be specified - this is enforced downstream.
 */
  final public Token parseOperation() throws ParseException {
    Token t, child;
    List children = null;
    t = jj_consume_token(START_OPERATION);
    label_16:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case START_REQUEST:
      case START_ELEMENT:
        ;
        break;
      default:
        jj_la1[46] = jj_gen;
        break label_16;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case START_REQUEST:
        child = parseRequest();
        break;
      case START_ELEMENT:
        child = parseUIComponent();
        break;
      default:
        jj_la1[47] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
            children = addChild(children, child);
    }
    jj_consume_token(END_OPERATION);
        if (visitor != null) { visitor.parseOperation(t, children); }
        {if (true) return t;}
    throw new Error("Missing return statement in function");
  }

/**
 * <mx:WebService>/<mx:operation>/<mx:request/> and <mx:HTTPService>/<mx:request/>.
 * Parsed as an anonymous object.
 * TODO: add metadata-driven ability to parse any property-initializing child tag as a key/value map.
 */
  final public Token parseRequest() throws ParseException {
    Token t, child = null;
    List children = null;
    t = jj_consume_token(START_REQUEST);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CDATA:
      child = jj_consume_token(CDATA);
                          children = addChild(children, child);
      break;
    default:
      jj_la1[49] = jj_gen;
      label_17:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case START_ELEMENT:
          ;
          break;
        default:
          jj_la1[48] = jj_gen;
          break label_17;
        }
        // LOOKAHEAD ( { "literal".equals(((Element) token).getAttribute("format")) ||
                        //              "xml".equals(((Element) token).getAttribute("format")) } )
                        //    child = parseXML() |
                            child = parseAnonymousObject();
                children = addChild(children, child);
      }
    }
    jj_consume_token(END_REQUEST);
        if (visitor != null) { visitor.parseRequest(t, children); }
        {if (true) return t;}
    throw new Error("Missing return statement in function");
  }

/***
 * <mx:HTTPService/>
 * Special child tag type <mx:request/>.
 * Note: at most one <mx:request/> child may be specified - this is enforced downstream.
 */
  final public Token parseHTTPService() throws ParseException {
    Token t, child;
    List children = null;
    t = jj_consume_token(START_HTTPSERVICE);
    label_18:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case START_REQUEST:
      case START_ELEMENT:
        ;
        break;
      default:
        jj_la1[50] = jj_gen;
        break label_18;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case START_REQUEST:
        child = parseRequest();
        break;
      case START_ELEMENT:
        child = parseUIComponent();
        break;
      default:
        jj_la1[51] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
            children = addChild(children, child);
    }
    jj_consume_token(END_HTTPSERVICE);
        if (visitor != null) { visitor.parseHTTPService(t, children); }
        {if (true) return t;}
    throw new Error("Missing return statement in function");
  }

/**
 *
 * END SERVICE TAGS
 *
 */

/**
 *
 */
  final public Token parseInlineComponent() throws ParseException {
    Token comp, child = null;
    comp = jj_consume_token(START_COMPONENT);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case START_DESIGNLAYER:
    case START_ELEMENT:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case START_DESIGNLAYER:
        child = parseDesignLayer();
        break;
      case START_ELEMENT:
        child = parseApplicationComponent();
        break;
      default:
        jj_la1[52] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[53] = jj_gen;
      ;
    }
    jj_consume_token(END_COMPONENT);
        if (visitor != null) { visitor.parseInlineComponent(comp, child); }
        {if (true) return comp;}
    throw new Error("Missing return statement in function");
  }

/**
 *
 */
  final public Token parseReparent() throws ParseException {
    Token t;
    t = jj_consume_token(START_REPARENT);
    jj_consume_token(END_REPARENT);
        if (visitor != null) { visitor.parseReparent(t); }
        {if (true) return t;}
    throw new Error("Missing return statement in function");
  }

/**
 * Start of tags in both MXML and FXG namespaces.
 */
  final public Token parsePrivate() throws ParseException {
    Token t;
    t = jj_consume_token(START_PRIVATE);
    label_19:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CDATA:
      case SKIP_ELEMENT:
        ;
        break;
      default:
        jj_la1[54] = jj_gen;
        break label_19;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SKIP_ELEMENT:
        jj_consume_token(SKIP_ELEMENT);
        break;
      case CDATA:
        jj_consume_token(CDATA);
        break;
      default:
        jj_la1[55] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(END_PRIVATE);
            {if (true) return t;}
    throw new Error("Missing return statement in function");
  }

/**
 * <Library> tag
 * Special child tag <Definition />
 * May have zero or more child Definitions.
 */
  final public Token parseLibrary() throws ParseException {
    Token lib, child = null;
    List children = null;
    lib = jj_consume_token(START_LIBRARY);
    label_20:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case START_DEFINITION:
        ;
        break;
      default:
        jj_la1[56] = jj_gen;
        break label_20;
      }
      child = parseDefinition();
            children = addChild(children, child);
    }
    jj_consume_token(END_LIBRARY);
        if (visitor != null) { visitor.parseLibrary(lib, children); }
        {if (true) return lib;}
    throw new Error("Missing return statement in function");
  }

/**
 * <Definition> tag for a Library
 * Has one attribute 'name' as an identifier.
 * At most one child may be specified.
 */
  final public Token parseDefinition() throws ParseException {
    Token definition, child = null;
    definition = jj_consume_token(START_DEFINITION);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case START_DESIGNLAYER:
    case START_ELEMENT:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case START_DESIGNLAYER:
        child = parseDesignLayer();
        break;
      case START_ELEMENT:
        child = parseApplicationComponent();
        break;
      default:
        jj_la1[57] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[58] = jj_gen;
      ;
    }
    jj_consume_token(END_DEFINITION);
        if (visitor != null) { visitor.parseDefinition(definition, child); }
        {if (true) return definition;}
    throw new Error("Missing return statement in function");
  }

  /** User defined Token Manager. */
  public TokenManager token_source;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[59];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0xaaaaaaaa,0xaaaaaaaa,0xaaaaaaa2,0xaaaaaaa2,0xaaaaaaa2,0xaaaaaaa2,0x2a0,0xaaaaa802,0xaaaaa802,0x0,0x0,0x0,0x0,0xaaaaa800,0xaaaaa802,0xaaaaa802,0xaa280000,0xaa280000,0x0,0x0,0x0,0x0,0x0,0xaa280802,0xaa280802,0xaa280802,0xaa280802,0x0,0x0,0xaa000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xaa080000,0xaa080000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x2,0x0,0x0,0x0,0x2,0x2,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x8aa820aa,0x8aa820aa,0x80a0002a,0x80a0002a,0x80a0002a,0x80a0002a,0x0,0x80a820aa,0x80a820aa,0x82080,0x0,0x0,0x0,0xa0002a,0x80a0002a,0x80a0002a,0x8000002a,0x8000002a,0x0,0x80000000,0x0,0x80000000,0x0,0x8080002a,0x8080002a,0x8080002a,0x8080002a,0x80000000,0x80000000,0x2a,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000200,0x80000200,0x80000800,0x80000800,0x8000002a,0x8000002a,0x0,0x80008000,0x80008000,0x80020000,0x80020000,0x80000000,0x0,0x80020000,0x80020000,0x80000000,0x80000000,0x0,0x0,0x20000000,0x80000000,0x80000000,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x1,0x1,0x1,0x1,0x1,0x1,0x0,0x0,0x0,0x0,0x1,0x1,0x1,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x1,0x0,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x0,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x5,0x5,0x0,0x0,0x0,};
   }


  /** Constructor with user supplied Token Manager. */
  public Parser(TokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 59; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(TokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 59; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[67];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 59; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 67; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

}
